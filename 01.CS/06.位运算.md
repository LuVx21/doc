<details>
<summary>点击展开目录</summary>

- [移位](#移位)
- [位](#位)
- [码](#码)

</details>

## 移位

|            | 正      | 负          |
| ---------- | ------- | ----------- |
| 左移       | 低位补0 | 低位补0(负) |
| 右移       | 高位补0 | 高位补1(负) |
| 无符号右移 | 高位补0 | 高位补0(正) |

## 位

|      |       | 说明                                            | Usage                                                                                    |
| ---- | ----- | ----------------------------------------------- | ---------------------------------------------------------------------------------------- |
| 与   | AND/& | 可视为只处理了`11->1`这种位, `00,01,10->0`      | 置零a二进制中最右边的1: `a&(a-1)`<br>两数位与: 找两数的最长公共后缀<br>`a&b <= min(a,b)` |
| 或   | OR/\| | 可视为只处理了`00->0`这种位, `11,10,01->1`      | <br>                                                                                     |
| 非   | ~     | 取反                                            | 相反数: `~a + 1 -> -a`<br>                                                               |
| 异或 | XOR/^ | 不同/相反->1, 相同 -> 0; `10/01->1`, `00,11->0` | `a^a=0`, `a^0=a`<br>返回原值a: `a^b^b`                                                   |

- 设置第k(右起始0)位为1: `n | (1 << k)`
- 设置第k(右起始0)位为0: `n & ~(1 << k)`
- 取出最小非0位(从右向左第一个1,截取到最后): `n & (-n)`
- 取出最小0位(从右向左第一个0,截取到最后,加一): `~n & (n + 1)`
- 第k位取反(右起始0): `n ^ (1 << k)`

## 码

|      |                                                                            | 正     | 负                                      |
| ---- | -------------------------------------------------------------------------- | ------ | --------------------------------------- |
| 原码 | 不直接参与运算                                                             | -      | -                                       |
| 反码 | 四则运算都可基于加法实现,但符号位存在导致效率低,因此产生反码               | 同原码 | 符号位不变,其他取反(对应正数的原码取反) |
| 补码 | 用二进制表示有符号数的方法, 转原码: `减1,符号位外取反`或`符号位外取反,加1` | 同原码 | 反码+1(对应正数的原码取反加一)          |
> 二进制数在内存中以补码的形式存储

```
补:11111001 减1
反:11111000 符号位外取反
原:10000111


补:11111001 符号位外取反
中:10000110 加1
原:10000111
```