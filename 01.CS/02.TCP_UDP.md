---
title: TCP/UDP
date: 2016-04-16
tags:
- TCP
---
<details>
<summary>点击展开目录</summary>
<!-- TOC -->

- [TCP](#tcp)
    - [组成](#组成)
    - [工作流程](#工作流程)
        - [三次握手](#三次握手)
        - [四次挥手](#四次挥手)
    - [可靠性传输的实现](#可靠性传输的实现)
    - [流量控制](#流量控制)
    - [拥塞控制](#拥塞控制)
- [UDP](#udp)
    - [组成](#组成-1)
    - [TCP对比](#tcp对比)
- [IP](#ip)
- [多路复用和多路分解](#多路复用和多路分解)
- [Q&A](#qa)

<!-- /TOC -->
</details>

# TCP

传输控制协议, 提供的是`面向连接`, `可靠的`, 基于`字节流`(把应用层传下来的报文看成字节流, 把字节流组织成大小不等的数据块)的传输层协议

提供`超时重发`,`丢弃重复数据`,`检验数据`,`流量控制`,`拥塞控制`,`全双工通信`等功能, 保证数据能从一端传到另一端

> * 单工: 数据传输只支持数据在一个方向上传输. 同一时间只有一方能接受或发送信息.如电视, 广播.
> * 半双工: 数据传输允许数据在两个方向上传输,但是在某一时刻,只允许数据在一个方向上传输,它实际上是一种可切换方向的单工通信; 在同一时间只可以有一方接受或发送信息, 可以实现双向通信. 如对讲机.
> * 全双工: 允许数据同时在两个方向上传输, 要求发送设备和接收设备都有独立的接收和发送能力; 在同一时间可以同时接受和发送信息, 如手机通信.

当应用层向传输层发送基于 TCP 协议的数据流时, 发送端会将数据流分割成适当长度的报文段, 之后将数据传给网路层发送出去

**特点**

1. 数据分片: 在发送端对数据进行分片, 在接收端进行重组
2. 接收确认: 接收端接收分片数据时, 根据分片序号向发送端发送ack
3. 超时重发: 发送方指定时间内没有收到接收方相应的确认则进行重发
4. 滑动窗口: TCP连接的每一方都有固定大小的缓冲空间, 接收端只允许发送端发送接收端缓冲区所能接纳的数据, TCP在滑动窗口的基础上提供流量控制, 防止较快主机致使较慢主机的缓冲区溢出
5. 失序处理: 接收端会对收到的数据进行重新排序, 将收到的数据以正确的顺序交给应用层
6. 重复处理: 接收端会将重复的数据丢弃
7. 数据校验: 接收端会对包进行校验以检测数据在传输过程中的任何变化. 校验出错则会丢弃这个分片且不对数据包进行 ack 确认导致发送端超时重发

## 组成

TCP的传输数据单元是报文段, 由首部和数据两部分组成

TCP 包的大小是 `1500 - IP头(20) - TCP头(20) = 1460 (Bytes)`

![](https://gitee.com/LuVx/img/raw/master/web/tcp_header.jpg)

对于标志位:
* SYN: 建立连接(Synchronize Sequence Numbers)
* FIN: 关闭连接(Finish)
* ACK: 确认响应(Acknowledge character)
* PSH: 有DATA数据传输
* RST: 连接重置(Reset)
* URG: 紧急指针字段值有效(urget pointer is vaild)

[IP, TCP, UDP首部详解](https://blog.csdn.net/zhangliangzi/article/details/52554439)

## 工作流程

### 三次握手

三次握手: 准备发信息,你准备好?   我准备好了,你准备发了吗?   我准备发了!
![](https://gitee.com/LuVx/img/raw/master/tcp_conn.png)

seq序号: 32位, 用来标识从TCP源端向目的端发送的字节流, 发起方发送数据时对此进行标记

ack序号: 32位, 只有ACK标志位为1时, ack序号字段才有效, `ack=seq+1`

1. 第一次握手:客户端发送syn包(syn=x)到服务器, 并进入`SYN_SENT`状态, 等待服务器确认;
2. 第二次握手:服务器收到syn包, 必须确认客户的SYN(ack=x+1), 同时自己也发送一个SYN包(syn=y), 即SYN+ACK包, 此时服务器进入`SYN_REVD`状态;
3. 第三次握手:客户端收到服务器的SYN＋ACK包, 向服务器发送确认包ACK(ack=y+1), 此包发送完毕, 客户端和服务器进入`ESTABLISHED`状态, 完成三次握手

> **为什么3次,而不是2次**
>
> TCP 是双工传输模式, 不区分客户端和服务端, 建立连接是双向过程
>
> 防止已失效的连接的请求报文突然又传送到了服务端,从而产生错误.
>
> 假设客户端的某次请求因为网络延迟直至连接断开后才被服务端收到, 服务端则返回响应
>
> 若是两次握手, 服务端的这次响应就已经和客户端创建起新的连接, 并处于等待客户端请求的状态, 但实际上客户端并没有发出请求, 可能接下来也不会再有请求, 造成服务端空等待.

### 四次挥手

四次挥手: 想关闭连接,再见?  OK,你关闭吧,再见!  我也关了连接,再见?  OK,再见!

![](https://gitee.com/LuVx/img/raw/master/tcp_release.jpg)

1. A 发送连接释放报文段, FIN=1, 进入`FIN-WAIT-1`状态.
2. B 收到之后发出确认,此时 TCP 属于半关闭状态(B 处于`CLOSEWAIT`),B 能向 A 发送数据但是 A 不能向 B 发送数据, A 接收到 B 的 ACK 后进入`FIN-WAIT-2`状态.
3. 当 B 不再需要连接时, 发送连接释放请求报文段,FIN=1, 进入`LASTACK`状态.
4. A 收到后发出确认,进入 `TIME-WAIT` 状态, 等待 2MSL 时间后释放连接.
5. B 收到 A 的确认后释放连接.

> **为什么四次挥手**
>
> 由于TCP连接时全双工的, 因此每个方向上都要单独关闭.
>
> 客户端发送了 FIN 连接释放报文之后, 服务器收到了这个报文,就进入了 CLOSE-WAIT 状态.
>
> 这个状态是为了让服务器端发送还未传送完毕的数据, 传送完毕之后, 服务器才会发送 FIN 连接释放报文.

> **TIME_WAIT**
>
> 客户端接收到服务器端的 FIN 报文后进入此状态, 此时并不是直接进入 CLOSED 状态,还需要等待一个时间计时器设置的时间 2MSL.这么做有两个理由:
>
> * 确保最后一个确认报文段能够到达, 保证连接的可靠关闭.如果服务端没收到客户端发送来的确认报文段,那么就会重新发送连接释放请求报文段,客户端等待一段时间就是为了处理这种情况的发生.
> * 等待一段时间是为了让本连接持续时间内所产生的所有报文段都从网络中消失,使得下一个新的连接不会出现旧的连接请求报文段.

## 可靠性传输的实现

**TCP可靠传输是如何实现的**

- 数据包校验
- 对失序数据包重排序
- 丢弃重复数据
- 应答机制
- 超时重传
- 流量控制
- 拥塞控制

**工作原理**

滑动窗口协议:

停止等待协议: 发送完一个分组就停止发送, 等待对方的确认, 只有对方确认过, 才发送下一个分组, 具有超时重传等机制, 但对信道的利用率太低

连续ARQ协议: 自动重传请求(Automatic Repeat-reQuest), 发送方维护一个窗口, 在窗口内的多个分组能被发送出去, 每收到一个确认, 窗口往后滑动一个分组

保证数据传输的正确性, 从而提供可靠的传输

提高信道利用率和吞吐量, 并起到控制流量的作用

![](https://gitee.com/LuVx/img/raw/master/slim_form1.jpg)

![](https://gitee.com/LuVx/img/raw/master/slim_form.jpg)

## 流量控制

流量控制: 让发送方的发送速率不要太快,让接收方来得及接受.

TCP连接的每一方都有固定大小的缓冲空间. TCP的接收端只允许发送接收端缓冲区所能接纳的数据, 这可以防止较快主机致使较慢主机的缓冲区溢出. 是点对点通信量的控制.

TCP 报头包含 16 位的窗口大小, 用于网络数据传输时的流量控制, 以避免拥塞,

发送方和接收方之间各自维持一个滑动窗口,其滑动是以字节为单位,允许发送方在停止并等待确认前发送多个数据分组,

之后在收到确认后,发送窗口才会向前滑动几个分组,超时未收到确认时,会依据Go-back-N(回退N)机制,回到最后接收到确认的地方进行重传

## 拥塞控制

发送方收到的确认报文中的窗口字段可以用来控制发送方窗口大小, 从而影响发送方的发送速率.

将窗口字段设置为 0,则发送方不能发送数据

TCP使用的流量控制协议是可变大小的滑动窗口协议,窗口单位是字节,不是报文段,发送方的发送窗口不能超过接收方给出的接收窗口的数值

拥塞控制: 防止过多的数据注入网络中,这样可以使网络中的路由器或链路不致过载.是一个全局性的过程.

ssthresh: 慢开始门限

cwnd: 拥塞窗口

![](https://gitee.com/LuVx/img/raw/master/congestion0.jpg)

![](https://gitee.com/LuVx/img/raw/master/congestion1.png)

控制方法:
* 慢启动:此方法适用阶段,发送数量翻倍增长
* 拥塞避免:此方法使发送数量每次加1
* 快重传:发送方连续收到3个来自接收方的确认, 就会重传
* 快恢复:丢失个别报文而不是拥塞,因此执行快恢复,此后直接进入拥塞避免,不会从慢启动开始

![](https://gitee.com/LuVx/img/raw/master/repost.png)

# UDP

User Datagram Protocol, 用户数据报协议, 传输层协议

用户数据报协议, 是一个`面向数据报`, `无连接`的, `不可靠`的(对于应用程序传下来的报文既不合并也不拆分,只是添加 UDP 首部), 尽最大可能交付, 没有拥塞控制的协议

## 组成

首部8个字节, UDP 包的大小就应该是 1500 - IP头(20) - UDP头(8) = 1472(Bytes)

![](https://gitee.com/LuVx/img/raw/master/Center2.png)

## TCP对比

[面向报文(UDP)和面向字节流(TCP)的区别](https://blog.csdn.net/liuyanfeier/article/details/52787037)

|      | TCP                                                   | UDP                                                          |
| :--- | :---------------------------------------------------- | :----------------------------------------------------------- |
| 1    | 面向字节流的,接收的是一堆数据, 而每次取多少由主机决定 | 面向报文的(不拆分, 不合并),客户发送多少就接收多少,因此是有界的 |
| 2    | 面向连接                                              | 无连接                                                       |
| 3    | 可靠且有序                                            | 不可靠且无序                                                 |
| 4    | 只支持点对点通信                                      | 支持一对一, 一对多, 多对一, 多对多的通信模式                 |
| 5    | 有拥塞控制机制, 会根据网络情况调整发送速度            | 没有拥塞控制, 发送速度保持不变                               |
| 6    | 首部开销(20个字节)                                    | 首部开销(8个字节)                                            |
| 7    | 效率低,准确性要求高                                   | 效率高,准确性要求低                                          |
| 8    | 文件传输,接收邮件, 远程登录                           | QQ聊天,媒体通信                                              |

# IP

![](https://gitee.com/LuVx/img/raw/master/Center1.png)

![](https://gitee.com/LuVx/img/raw/master/web/ip_header.jpeg)

# 多路复用和多路分解

主机间的通信实质上是主机上应用程序间的通信,正是多路分解与多路复用的存在保证了对应应用程序间正确通信.

当程序需要使用网络时,会向OS申请,OS会创建socket,并返回其id,程序根据此id读写数据,即收发信息.socket都有唯一标识符—端口号.

多路复用: 从源端各socket收集数据, 为每个数据块封装上首部信息从而生成报文段, 之后传给网络层.

多路分解: 接收端检查字段, 检查端口号并标记出消息对应的socket, 之后发送到该socket

# Q&A

