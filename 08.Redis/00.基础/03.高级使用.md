<details>
<summary>Redis高级</summary>
<!-- TOC -->

- [模块化](#模块化)
- [RediSearch](#redisearch)
- [Redis-ML](#redis-ml)
- [Q\&A](#qa)
- [参考](#参考)

<!-- /TOC -->
</details>

## 模块化

从4.0版本开始支持模块.

模块是一种动态库, 可以以与Redis内核相似的运行速度和特性来扩展Redis内核的功能

## RediSearch

高性能的全文搜索引擎, 可作为一个Redis Module 运行在Redis上

```shell
docker pull redislabs/redisearch:latest
```

## Redis-ML

机器学习模型服务器

[用Redis-ML模块实现实时机器学习](http://dbaplus.cn/news-21-1305-1.html)

## Q&A

**作为消息队列使用**

list的存储结构是一个双向队列, 队首队尾都可以操作, 只要一方入, 一方出即可用作于消息队列.

在出队列时候可能会遇到队列为空, 此时可以在使用普通的`lpop`或`rpop`时适当地sleep一定时间, 或者直接使用阻塞式出队方式`blpop`或`brpop`.

通常的消息中间件都支持一对一, 一对多生产消费模式, 使用redis作为消息队列遇到这种一对多模式时, 可以采用redis的`pub/sub`主题订阅者模式, 多个客户端可以订阅同一个生产者.

实际上, redis仅仅是可以用作消息队列, 但终究不能和专业的消息中间件相比, 如一对多模式下, 消费者掉线就会发生消息丢失.

同样的某些消息中间件还提供了延迟队列, Redis怎么实现?

可以使用 `sortedset`, 使用时间戳作为score, 消息内容作为value来生产消息, 消费者用 `zrangebyscore` 指令轮询获取特定时间点(如1ms前)的消息.

**Redis实现分布式锁**

使用`setnx`命令来获取锁, 获取到之后, 用`expire`给锁设置一个过期时间防止锁忘记了释放

通常可以将需要同步的区域计算成唯一性id作为key使用, 但在`setnx之后expire之前`系统可能出现宕机等异常情况, 这就导致过期时间没有被正确设置, 从而使锁无法释放

此时可以将`setnx`和`expire`一起作为一个原子操作来进行, 要么加锁失败, 要么两个命令都正确执行,

> 但这样两个操作不是原子的, 新版的 redis `set`命令已支持将这两个操作原子执行

可能存在的问题:

* 锁超时问题: 任务执行时间大于过期时间, 过期后被别的客户端加锁成功
* 锁误删除: 锁超时问题基础上, 任务执行完成, 释放锁时不是自己所加的锁

或者方案2: 将当前时间和失效时间进行组合作为value, 就可以不用expire命令. 但逻辑出现异常后必须释放锁

**redis是单线程的**

由于redis是单线程, 一个操作进行时就会阻塞另一个线程, 在线上环境使用就要当心.

如使用`keys`指令查看某些数据, 此时可以考虑使用`scan`命令, 它可以无阻塞提取特定规则的数据, 但数据可能存在重复.

**Pipeline**

客户端一次发送多条命令并在执行完后将结果一并返回, 当然前提是pipeline执行的指令之间没有依赖性, 是通过减少C/S之间通信次数来降低交互时间.

Pipeline的实现也是基于队列, 从而保证了数据的顺序性.

值得注意的是, server是一次性将结果返回的, 所以在返回之前都是将前面命令的执行结果保存起来, 因此打包的命令越多, 内存占用也会越多.

使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目.


## 参考

[BloomFilter解决缓存击穿](https://blog.csdn.net/tianyaleixiaowu/article/details/74721877)
