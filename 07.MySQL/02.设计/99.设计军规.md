<details>
<summary>点击展开目录</summary>
<!-- TOC -->

- [库设计](#库设计)
- [表设计](#表设计)
    - [主键设计](#主键设计)
- [字段设计](#字段设计)
- [索引设计](#索引设计)

<!-- /TOC -->
</details>


## 库设计


## 表设计

1. 必须使用 InnoDB 存储引擎
2. 表字符集默认使用 utf8, 必要时候使用 utf8mb4
3. 数据表, 数据字段必须加入中文注释
4. 禁止存储大文件或者大照片
5. 控制单表数据量, 单表记录控制在千万级
6. 平衡范式与冗余, 为提高效率可以牺牲范式设计, 冗余数据
7. 单实例表个数必须控制在2000个以内, 单表分表个数必须控制在1024个以内, 单表列数目必须小于30

### 主键设计

主键的作用:
1. 保证实体的完整性
2. 加快数据库的操作速度
3. 在表中添加新记录时, 数据库会自动检查新记录的主键值, 不允许该值与其他记录的主键值重复.
4. 数据库自动按主键值的顺序显示表中的记录. 如果没有定义主键, 则按输入记录的顺序显示表中的记录.

主键不是非要不可, 可以从:

1. 是否满足业务要求
2. 数据查询效率(主键可以提高查询效率, 当然合理的索引替代也可以)

这两个角度权衡是否需要主键

实际上, mysql的innodb引擎会给没有主键的表生成一个隐藏列作为主键字段

综上所述, 推荐在表中设计上主键, 如果没有业务上的主键, 可以设计一个主键仅用于区分数据

通常场景下自增主键即满足使用:
```sql
`id` bigint(20) unsigned not null auto_increment comment '主键id',
```

**主键类型的选择: 使用自增还是uuid**

自增:
* 优点:
    1. 有序, 范围查询性能好
    2. 插入性能好, 占用空间小
* 缺点:
    1. 不适用于分库, 分布式场景下(id的产生依赖于数据库服务)

uuid:
* 优点:
    1. 可以用来做分布式 id 更方便(分库, 分布式都适用)
    2. 具有唯一性, 可以让数据分布的更均匀
    3. 字符串可以屏蔽掉 java 和 js 的一些数据类型差异, 比如使用 Long 时如果数字过大会产生问题
    4. 避免自增的可猜测, 传入恶意id, 试图绕过验证
* 缺点:
    1. 太长了, 主键会被用作聚簇索引, 每次插入都要损耗不少性能, bigint 也才 8 个字节
    2. 临近的数据没有相关性, 不能有效利用局部性原理节省性能
    3. 进行范围查询时会扫描过多的页, 性能不好, 这点和 2 类似.
    4. 占用空间大(不算太大问题)

> 可定义为`char(32)`
>
> 优先推荐使用 Twitter 的 snowflake 算法, 但需要记得在最外层和前端交互时使用 String

## 字段设计

数据类型的选择遵循小而简单的原则

整型比字符类型操作代价小, 因此在能用整型的前提下优先使用整型

**not null**

1. 索引性能好
2. count时结果准确
3. 空间占用, 如 `''`不占用空间, 而`null`则是占用空间

**字段设置default为`null`好, 还是`''`好**

《高性能mysql》中是这么说的:

尽量避免NULL

通常情况下最好指定列为 NOT NULL, 除非真的需要存储 NULL 值;
mysql表定义时如果没有指定列为 NOT NULL, 默认都是允许 NULL 的;

如果查询中包含可为NULL的列, 对mysql来说更难优化.
因为可为NULL的列, 使得索引, 索引统计, 值比较, 都更复杂;

可为NULL的列会使用更多的存储空间, 在MYSQL里也需要特殊处理.

当可为NULL的列被索引时, 每个索引记录需要一个额外的字节, 在MyISAM里甚至还可能导致固定大小的索引(例如只有一个整数列的索引)变成可变大小的索引;

通常, 把可为NULL的列改为NOT NULL带来的性能提升比较小, 所以调优时没有必要首先修改这种情况, 除非确定这会导致问题;

但是如果计划在列上建索引, 就应该尽量避免设计成可为NULL的列. 当然也有例外, 比如InnoDB使用单独的bit存储NULL的值, 对稀疏数据有很好的空间效率. 这一点不适用于MyISAM.
(稀疏数据: 是指很多值都是NULL, 少数值是非NULL)

**IP存储**

如IP的存储, 可以使用`int(10) unsigned`(4个字节, 32位)存储, 每8位对应ip的一组

MySQL提供了ip相关的函数:

```sql
select inet_aton('192.168.1.1'), inet_ntoa(3232235777);
```

**审计字段**

推荐给每个表都添加一下字段:
```sql
`create_time` timestamp not null default current_timestamp comment '创建时间',
`create_user` varchar(255) not null default '',
`update_time` timestamp not null default current_timestamp on update current_timestamp comment '更新时间',
`update_user` varchar(255) not null default '',
```
`timestamp`使用4个字节存储空间, 而`datetime`使用8个,
1. timestamp: 带有时区信息但范围小, 值会随着时区变化而变化
2. datetime: 范围大但不带有时区信息

> 自动记录数据插入修改时间

**枚举字段**

不推荐使用enum类型, 而推荐直接使用`tinyint(1)`
1. enum内部其实也是使用的`tinyint`
2. enum有索引值和实际值, 索引值从1开始; 当实际值为数字时, 容易产生误解

**货币值选型**

精确到整数级别可以使用`int`, 否则选用`Decimal`,
不能使用`float`或`double`, 会存在误差

实际上, `Decimal`(运算代价高)的使用完全可以使用整型替代, 通过移动小数点的方式使用整型, 即使是货币数值

## 索引设计

1. 联合索引, 区分度高的字段放在前面
2. 不要在写频繁的, 区分度不高的字段上建立索引
3. 控制单字段索引的数量(<=5)
