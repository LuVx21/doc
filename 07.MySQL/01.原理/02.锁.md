<details>
<summary>点击展开目录</summary>
<!-- TOC -->

- [锁](#锁)
- [锁算法](#锁算法)
    - [间隙锁](#间隙锁)
    - [next-key](#next-key)
- [封锁协议](#封锁协议)

<!-- /TOC -->
</details>

## 锁

并发控制机制:
* 悲观锁: 读写整个过程都要加锁, 依靠数据库提供的锁机制, 实现一致性锁定读, 为了提高性能, 派生出各种不同粒度(表锁, 行锁), 性质(X, S锁)的锁
* 乐观锁: 每行添加一个version字段, 随着更新, version递增, 写入的时候, 比较版本号, 写入的版本小于当前版本号则更新失败, 除了使用版本号以外, 也可以使用时间戳, 本质上是一样的.
> 本质上并不是同一种东西, 一个是一种思想, 另一个是真正的锁, 但是它们都是一种并发控制机制

锁种类:
* S锁: 共享锁, 其它事务可以继续加共享锁, 但不能加排它锁
* X锁: 排它锁, 其它事务不能再获得任何锁

锁类型:
* 表锁: 对整张表进行加锁, 会导致并发能力下降, 如DDL, 无条件的写操作, 未使用索引的有条件写操作等.
* 行锁: 只锁定使用的数据, 并发能力强, 如使用了索引的写操作

锁模式:

读锁, 写锁, 自增锁, 读意向锁, 写意向锁

> 自增锁(AI锁): 自增值一旦分配了就会 +1, 如果事务回滚, 自增值也不会减回去, 所以自增值可能会出现中断的情况.

锁粒度:

* 意向共享锁: 事务想要在获得表中某些记录的共享锁, 需要在表上先加意向共享锁
* 意向互斥锁: 事务想要在获得表中某些记录的互斥锁, 需要在表上先加意向互斥锁

## 锁算法

### 间隙锁

间隙锁: 能否插入整个锁的前后两个边界值, 取决于聚簇索引

间隙锁和间隙锁之间是互不冲突的, 间隙锁唯一的作用就是为了防止其他事务的插入.

唯一索引不会有间隙锁, 除非是由于二级索引上的gap锁引起的聚簇索引加gap锁

### next-key

插入意向锁: 和插入意向锁之间互不冲突(行级锁)和上面的表级别的写意向锁不同.

插入意向锁又叫(II GAP)Insert Intention GAP, 也是一种 GAP 锁

> 插入意向锁只会和间隙锁或 Next-key 锁冲突, 正如上面所说, 间隙锁唯一的作用就是防止其他事务插入记录造成幻读, 那么间隙锁是如何防止幻读的呢?
>
> 正是由于在执行 INSERT 语句时需要加插入意向锁, 而插入意向锁和间隙锁冲突, 从而阻止了插入操作的执行

(不走索引的加锁流程)注意: 如果 SQL 语句无法使用索引时会走主索引实现全表扫描, 这个时候 MySQL 会给整张表的所有数据行加记录锁.

如果一个 WHERE 条件无法通过索引快速过滤, 存储引擎层面就会将所有记录加锁后返回, 再由 MySQL Server 层进行过滤.

不过在实际使用过程中, MySQL 做了一些改进, 在 MySQL Server 层进行过滤的时候, 如果发现不满足, 会调用 unlock_row 方法, 把不满足条件的记录释放锁(显然这违背了两段锁协议).
这样做, 保证了最后只会持有满足条件记录上的锁, 但是每条记录的加锁操作还是不能省略的.
可见在没有索引时, 不仅会消耗大量的锁资源, 增加数据库的开销, 而且极大的降低了数据库的并发性能, 所以说, 更新操作一定要记得走索引.


## 封锁协议

**从锁的角度分析数据成因及解决**

脏读: RU级别下, 写操作加X锁, 读不加锁, 没有多余的机制保证数据读取的一致性, 因此能够读到未提交的数据.

不可重复读: RC级别下, 写同样加X锁, 读不加锁, 引入MVCC机制解决了脏读问题, 因为事务列表`read view`的更新频率(或时机)导致不可重复读现象

幻读: 没有锁表的查询, 是能够插入新数据的, 从而导致幻读, RR级别下, 基于`MVCC`, `Next-Key`机制一定程度上解决了幻读问题, 彻底解决还是在串行级别.

> 仅会对写写操作加锁, 这是导致脏读和不可重复读的原因