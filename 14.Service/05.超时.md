<details>
<summary>点击展开目录</summary>

- [目标](#目标)
- [形态](#形态)
- [确定超时时间](#确定超时时间)

</details>

## 目标

确保客户端能在预期的时间内拿到响应(坏响应也比没响应好)
及时释放资源(提高系统可用性)

## 形态

**调用超时控制**

比如说你在调用下游接口的时候, 为这一次调用设置一个超时时间.

**链路超时控制**

是指整条调用链路被一个超时时间控制
作用于整个链路的任何一环

比如说你的业务有一条链路是 A 调用 B, B 调用 C
如果链路超时时间是 1s, 首先 A 调用 B 的超时时间是 1s, 如果 B 收到请求的时候已经过去了 200ms, 那么 B 调用 C 的超时时间就不能超过 800ms

因此关键是在链路中传递超时时间, 如使用协议头

大部分情况下, 链路超时时间在网络中传递是放在协议头的
如果是 RPC 协议, 那么就放在 RPC 协议头, 比如说 Dubbo 的头部; 如果是 HTTP 那么就是放在 HTTP 头部
比较特殊的是 gRPC 这种基于 HTTP 的 RPC 协议, 它是利用 HTTP 头部作为 RPC 的头部, 所以也是放在 HTTP 头部的.
至于放的是什么东西, 就取决于不同的协议是如何设计的了.


一般超时时间传递的就两种: `剩余超时时间`或者`超时时间戳`.
比如说剩余 1s, 那么就用毫秒作为单位, 数值是 1000.
这种做法的缺陷就是服务端收到请求之后, 要减去请求在网络中传输的时间.
比如说 C 收到请求, 剩余超时时间是 500ms, 如果它知道 B 到 C 之间请求传输要花去 10ms, 那么 C 应该用 500ms 减去 10 ms 作为真实的剩余超时时间.
不过现实中比较难知道网络传输用了多长时间.

而传递超时时间戳, 那么就会受到时钟同步影响.
假如说此时此刻, A 的时钟是 00:00:00, 而 B 的时钟是 00:00:01, 也就是 A 的时钟比 B 的时钟慢了一秒.
那么如果 A 传递的超时时间戳是 00:00:01, 那么 B 一收到请求, 就会认为这个请求已经超时了.

当然, 正常来说时钟同步不至于出现那么大的偏差, 大多数时钟偏差几乎可以忽略不计.
不过在时钟回拨的场景下, 还是会有问题.


## 确定超时时间


* 用户体验来确定
* 被调用接口的响应时间来确定
  * 99线
* 压测结果来确定
* 代码来确定.
  * `接口的响应时间=数据库响应时间 * 3 + Redis 响应时间 + 发送消息的响应时间`
