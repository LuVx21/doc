---
title: 单例模式
date: 2017-07-01
tags:
- 设计模式
---
<!-- TOC -->

- [关于](#关于)
- [懒汉式](#懒汉式)
- [饿汉式](#饿汉式)
- [懒汉式改造](#懒汉式改造)
    - [使用synchronized](#使用synchronized)
    - [降低锁粒度](#降低锁粒度)
    - [双重校验锁](#双重校验锁)
    - [静态内部类](#静态内部类)
    - [不被反射破坏](#不被反射破坏)
    - [不被反序列化破坏](#不被反序列化破坏)
- [饿汉式改造](#饿汉式改造)
- [枚举类实现](#枚举类实现)
- [总结](#总结)
- [Q&A](#qa)

<!-- /TOC -->

# 关于

单例模式,顾名思义就是要求一个类在任何时间只允许有1个实例,
为保证仅有1个,就要避免开发者随意创建,因此要把创建的入口封住,避免外部创建,需要显示声明构造函数为`private`
由于无法外部创建对象,那么普通方法也就无法使用(普通方法依赖于对象存在),因此需要声明获取实例的方法`getInstance()`为`static`,
由于`static`的特性,静态方法内部无法使用非静态属性,因此那个唯一的实例也需要声明为`static`

综上所述,实例声明为`private static`,方法声明为`public static`,因此也能总结出单例模式的特点:

* 某一个类只有一个实例
* 自行实例化并向整个系统提供这个实例
* 外部能间接获得该对象实例

# 懒汉式

根据上述定义和单例模式的特点,能够代码实现最简单的单例模式:

```Java
public class Singleton{
    private static Singleton INSTANCE;
    private Singleton(){}
    public static Singleton getInstance(){
        if (INSTANCE == null){
            INSTANCE = new Singleton();
        }
        return INSTANCE;
    }
}
```

这种实现下,只有在用到该实例时在会创建该实例,因此叫懒汉式.

# 饿汉式

在懒汉式的实现下,无法应对并发的环境,因为会出现多个实例的现象,如线程a创建对应实例时,线程b可能运行到判空,从而进入条件语句内部,导致线程a,b各创建一个对象.
基于此考虑,可以在类加载的时候就创建实例,之后不再提供创建实例的可能.如下:

```Java
public class Singleton{
    private static final Singleton INSTANCE = new Singleton();
    private Singleton(){}
    public static Singleton getInstance(){
        return INSTANCE;
    }
}
```
这种实现是不管那么多,先创建了再说,因此叫饿汉式,但其缺点也显而易见,会始终占用内存.

和懒汉式相比可以看出,变量中多了`final`,那么这个修饰是否必要?
从整体考虑,除非使用反射,除此之外无法再创建一个对象赋值给这个变量,为保持良好习惯还是将其保留.

# 懒汉式改造

由于饿汉式的缺点和基于性能的考虑,可以尝试返回懒汉式,通过对其改造,以满足线程安全.

## 使用synchronized

此种实现就是在获取实例的方法上加锁,避免被多个线程同时使用,实现上仅多了一个`synchronized`.

```Java
public static synchronized getInstance(){
    if (INSTANCE == null){
        INSTANCE = new Singleton();
    }
    return INSTANCE;
}
```

此种实现虽然保证了线程安全,但同时也会阻塞线程,在高并发环境下造成性能下降.

## 降低锁粒度

并发性能优化的一种方式就是降低锁粒度,即缩小加锁的区域,这样就减小了可能造成阻塞的区域.
在上述的基础上,就可以不用对整个方法进行加锁,仅仅对创建对象过程加锁.

```Java
public static getInstance(){
    if (INSTANCE == null) {
        synchronized(Singleton.class){
            INSTANCE = new Singleton();
        }
    }
    return INSTANCE;
}
```

实际上,此种实现仍然可能出现多实例的情形,如线程a进入同步域,线程b进入判空条件,由于a线程拥有锁,b只能等待,
a释放锁后,b进入同步域,但实际上单例实例已经被a创建,导致出现多个实例.
这种实现没有太大的意义,只是为理解双重校验锁方式的过渡.

## 双重校验锁

基于上述不安全的实现,为达到安全点的目的,需要在同步域中再进行一次判空操作.

```Java
private volatile static Singleton INSTANCE;
public static getInstance(){
    if (INSTANCE == null) {
        synchronized(Singleton.class){
            if (INSTANCE == null){
                INSTANCE = new Singleton();
            }
        }
    }
    return INSTANCE;
}
```

在这种实现中,实例对象的修饰符中需要添加`volatile`修饰,该修饰符有诸多作用,
此处使用主要是利用了其能够保证变量的强一致性的特点(个人认为此处没有使用其能够避免指令重排的特点),
即线程a对变量的修改能够立即被线程b获取到,从而避免线程b用空值进行第二层判空操作.
如果不是`volatile`,即使有双重锁也是可能出现多实例的.

## 静态内部类

```Java
private final static class SingletonHolder{
    private static final Singleton INSTANCE = new Singleton();
}
private Singleton(){}
public static final Singleton getInstance(){
    return SingletonHolder.INSTANCE;
}
```

分析至此,可以清楚的理解,懒汉式只有在使用实例的时候才创建实例(延迟加载),避免占用内存,而饿汉式在创建变量的同时创建对象,从而保证线程安全.
使用静态内部类,只有在调用`getInstance()`时候才会加载内部类,是一种结合了懒汉式和饿汉式优点的实现,避免占用内存同时保证线程安全.

子类实例化会使父类的静态内容执行,因此内部类需要使用`final`.


## 不被反射破坏

```Java
private static boolean initialized = false;
private Singleton() {
    synchronized (Singleton.class) {
        if (initialized == false) {
            initialized = !initialized;
        } else {
            throw new RuntimeException("can not create second object!");
        }
    }
}
private final static class SingletonHolder{
    private static final Singleton INSTANCE = new Singleton();
}
public static final Singleton getInstance(){
    return SingletonHolder.INSTANCE;
}
```

使用变量标记是否已创建实例,已创建的前提下使用反射创建多余的实例时,会出现异常.

## 不被反序列化破坏

```Java
public class Singleton implements Serializable {
    private static boolean initialized = false;
    private Singleton() {
        synchronized (Singleton.class) {
            if (initialized == false) {
                initialized = !initialized;
            } else {
                throw new RuntimeException("can not create second object!");
            }
        }
    }
    private final static class SingletonHolder {
        private static final Singleton instance = new Singleton();
    }
    public static final Singleton getInstance() {
        return SingletonHolder.instance;
    }
    private Object readResolve() {
        return getInstance();
    }
}
```


实现`readResolve()`方法,

# 饿汉式改造

静态代码块实现

```Java
private static Singleton INSTANCE = null;
static {
    INSTANCE = new Singleton();
}
private Singleton(){}
public static getInstance(){
    return INSTANCE;
}
```

由于需要在静态代码块中为变量赋值,此处无法使用`final`修饰.

# 枚举类实现

```Java
public enum Singleton{
    INSTANCE;
}
```

# 总结

|实现|线程安全|
|:---|:---:|
|懒汉式|×|
|饿汉式|√|
|使用synchronized|√|
|双重校验锁|√|
|静态内部类|√|
|静态内部类|√|
|枚举类|√|

# Q&A

***枚举类实现的单例模式是怎样实现单例的创建的,以及怎样保证线程安全的?***

枚举类:继承自`java.lang.Enum`的final类
其枚举变量为`public static final`的该类的对象
values():该类类型的数组
valueOf:依据String对象,获取对应该类的对象


***为什么静态内部类的单例模式是最推荐的?***

***如何在反射的情况下保证单例?***

***如何在反序列化中保证单例?***
