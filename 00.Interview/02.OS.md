---
title: 面试准备:操作系统
date: 2018-03-20
tags:
- Java
categories:
- 面试
---
<!-- TOC -->

- [操作系统](#操作系统)
- [内存管理](#内存管理)
- [Q&A](#qa)
- [参考](#参考)

<!-- /TOC -->

# 操作系统

四个特性
1. 并发(concurrence)
并行性是指两个或者多个事件在同一时刻发生,这是一个具有微观意义的概念,即在物理上这些事件是同时发生的;
并发性是指两个或者多个事件在同一时间的间隔内发生,它是一个较为宏观的概念.
在操作系统中,并发多是针对进程而言,进程,又称任务,简单来说,是指在系统中能独立运行并作为资源分配的基本单位,它是一个活动的实体.一个进程在运行时需要一定的资源,如 cpu,及i/o设备等,因此多进程之间并发执行伴随着信息交换.
2. 共享 (sharing)
共享是指,系统中的资源可供内存中多个并发执行的进程共同使用.由于资源的属性不同,故多个进程对资源的共享方式也不同,可以分为: `互斥共享` 和 `同时访问`
3. 虚拟 (virtual)
是指通过技术把一个物理实体变成若干个逻辑上的对应物.在操作系统中虚拟的实现主要是通过分时的使用方法.显然,如果n是某一个物理设备所对应的虚拟逻辑设备数,则虚拟设备的速度必然是物理设备速度的1/n.
4. 异步 (asynchronism)
在多道程序设计环境下,允许多个进程并发执行,由于资源等因素的限制,通常,进程的执行并非"一气呵成",而是以"走走停停"的方式运行.
内存中每个进程在何时执行,何时暂停,以怎样的方式向前推进,每道程序总共需要多少时间才能完成,都是不可预知的.或者说,进程是以一步的方式运行的.尽管如此,但只要运行环境相同,作业经过多次运行,都会获得完全相同的结果.

主要功能
* 处理器管理
* 存储器管理
* 文件管理
* 设备管理

> 操作系统的发展主要经历了单道批处理系统, 多道批处理系统, 分时系统, 实时系统, 网络与分布式系统和多机系统等.

# 内存管理

分段,分页
虚拟内存

页面置换算法:

FIFO先进先出算法:在操作系统中经常被用到,比如作业调度(主要实现简单,很容易想到);
LRU(Least recently use)最近最少使用算法:根据使用时间到现在的长短来判断;
LFU(Least frequently use)最少使用次数算法:根据使用次数来判断;
OPT(Optimal replacement)最优置换算法:理论的最优,理论;就是要保证置换出去的是不再被使用的页,或者是在实际内存中最晚使用的算法.

进程间通信方式:

* 管道(pipe):管道是一种半双工的通信方式,数据只能单向流动,而且只能在具有亲缘关系的进程间使用.进程的亲缘关系通常是指父子进程关系.
    * 普通管道PIPE, 通常有种限制,一是半双工,只能单向传输;二是只能在父子进程间使用.
    * 流管道s_pipe:去除了第一种限制,可以双向传输.
    * 命名管道(named pipe):也是半双工的通信方式,去除了第二种限制,允许无亲缘关系进程间的通信
* 信号 (sinal):信号是一种比较复杂的通信方式,用于通知接收进程某个事件已经发生.
* 消息队列(message queue):消息队列是由消息的链表,存放在内核中并由消息队列标识符标识.消息队列克服了信号传递信息少, 管道只能承载无格式字节流以及缓冲区大小受限等缺点.
* 共享内存(shared memory):共享内存就是映射一段能被其他进程所访问的内存,这段共享内存由一个进程创建,但多个进程都可以访问.共享内存是最快的 IPC 方式,它是针对其他进程间通信方式运行效率低而专门设计的.它往往与其他通信机制,如信号两,配合使用,来实现进程间的同步和通信.
* 信号量(semophore):信号量是一个计数器,可以用来控制多个进程对共享资源的访问.它常作为一种锁机制,防止某进程正在访问共享资源时,其他进程也访问该资源.因此,主要作为进程间以及同一进程内不同线程之间的同步手段.
* 套接字(socket):套解口也是一种进程间通信机制,与其他通信机制不同的是,它可用于不同及其间的进程通信.

[进程间通信(IPC)介绍](http://www.cnblogs.com/CheeseZH/p/5264465.html)

***进程调度策略***

* FCFS(先来先服务,队列实现,非抢占的):先请求CPU的进程先分配到CPU
* SJF(最短作业优先):平均等待时间最短,但难以知道下一个CPU区间长度
* 优先级调度算法(可以是抢占的,也可以是非抢占的):优先级越高越先分配到CPU,相同优先级先到先服务,存在的主要问题是:低优先级进程无穷等待CPU,会导致无穷阻塞或饥饿;解决方案:老化
* 时间片轮转调度算法(可抢占的):队列中没有进程被分配超过一个时间片的CPU时间,除非它是唯一可运行的进程.如果进程的CPU区间超过了一个时间片,那么该进程就被抢占并放回就绪队列.
* 多级队列调度算法:将就绪队列分成多个独立的队列,每个队列都有自己的调度算法,队列之间采用固定优先级抢占调度.其中,一个进程根据自身属性被永久地分配到一个队列中.
* 多级反馈队列调度算法:与多级队列调度算法相比,其允许进程在队列之间移动:若进程使用过多CPU时间,那么它会被转移到更低的优先级队列;在较低优先级队列等待时间过长的进程会被转移到更高优先级队列,以防止饥饿发生.


# Q&A

***导致死锁的四个必要条件***

* 互斥:至少有一个资源必须属于非共享模式,即一次只能被一个进程使用;若其他申请使用该资源,那么申请进程必须等到该资源被释放为止;
* 占有并等待:一个进程必须占有至少一个资源,并等待另一个资源,而该资源为其他进程所占有;
* 非抢占:进程不能被抢占,即资源只能被进程在完成任务后自愿释放
* 循环等待:若干进程之间形成一种头尾相接的环形等待资源关系

***处理死锁的四个方式***

1. 鸵鸟策略,处理死锁问题的代价很大,这是忽视死锁问题的一种策略,适用于死锁极少发生的情形
2. 检测死锁并且恢复.
3. 通过破除死锁四个必要条件之一,以确保循环等待条件不成立,来预防死锁.
4. 仔细地对资源进行动态分配,以避免死锁.

***死锁检测,解除***

* 进程终止:终止处于死锁状态下的某进程或全部进程以打破循环等待状态
* 进程回退:回退导致循环等待的进程到没有发生死锁前的某处
* 资源抢占

***死锁预防的方法**

针对死锁产生的条件进行预防:
* 打破互斥:将资源设为共享,不符合实际需求,实用意义不大
* 打破占有并等待:配置等待超时,指定时间后无法获取锁,就退出等待状态并释放自身拥有的锁
* 打破非抢占:允许抢占资源
* 打破循环等待:实行资源有序分配策略

***死锁避免的方法***

* 安全序列:寻找一个安全序列,使得所有进程能够按照某一种次序分配资源,并且依次地运行完毕,如果存在这样的序列,那么系统是安全的
* 银行家算法

在避免死锁的方法中,允许进程动态地申请资源,但系统在进行资源分配之前,应先计算此次资源分配的安全性.
若此次分配不会导致系统进入不安全状态,则将资源分配给进程; 否则,令进程等待.
其实质是动态地检测资源分配,以确保循环等待条件不成立,从而确保系统始终处于安全状态.

> 死锁的预防是使死锁的4个产生条件不会同时满足,对进程申请资源的活动加以限制,保证系统不会进入死锁状态,是一种静态策略
> 死锁的避免是不限制进程有关申请资源的命令,而是对每一个申请资源命令加以动态地检查,根据检查结果决定是否分配资源,是一种动态策略

**虚拟内存的定义及实现方式**

[虚拟内存的定义及实现方式](https://blog.csdn.net/u014590757/article/details/80452618)

**内核态与用户态**

内核态: cpu可以访问内存的所有数据, 包括外围设备, 例如硬盘, 网卡, cpu也可以将自己从一个程序切换到另一个程序.
用户态: 只能受限的访问内存, 且不允许访问外围设备, 占用cpu的能力被剥夺, cpu资源可以被其他程序获取.

[Linux探秘之用户态与内核态](https://www.cnblogs.com/bakari/p/5520860.html)

<!--
* 进程的有哪几种状态,状态转换图,及导致转换的事件
* 内存连续分配方式采用的几种算法及各自优劣
* 基本分页储存管理方式
* 基本分段储存管理方式
* 分段分页方式的比较各自优缺点
* 几种页面置换算法,会算所需换页数
为什么要内存对齐;
为什么会有大端小端,htol这一类函数的作用;
-->


# 参考

[]()
