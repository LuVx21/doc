---
title: 数据结构:B/B+树
date:
tags:
- MySQL
---
<details>
<summary>点击展开目录</summary>
<!-- TOC -->

- [多路搜索树](#多路搜索树)
- [B树](#b树)
- [B+树](#b树-1)
- [红黑树](#红黑树)
  - [基本知识](#基本知识)
  - [变色](#变色)
  - [旋转](#旋转)
  - [应用实例](#应用实例)
  - [参考](#参考)
- [QA](#qa)
- [参考](#参考-1)

<!-- /TOC -->
</details>

# 多路搜索树

减少平衡二叉树的高度, 使用多路搜索树

问: B+树的特点是什么
答: B+树的特点就是子节点多, 层数少. 子节点深度一致. 所有子节点组成一个链表.
问: 为啥这样搞
答: 因为层数少减少 IO 次数. 子节点深度一致, 查询性能稳定. 链表更好地支持范围查询.

无论红黑还是 B 树, 都是用来解决搜索问题的, 搜索越快越好嘛.

其实最初的, 就是二叉搜索树. 如果这颗树比较平衡的话, 其搜索效率就等同于二分查找了.

但是呢? 现实是, 二叉搜索树不平衡, 如果不平衡, 你想想, 搜索效率就很差了.

所以呢? 能不能构建二叉搜索树时能让它尽量平衡一些?

于是就有了平衡二叉搜索树.

但是呢, 平衡二叉搜索树插入删除比较麻烦. 为了这种平衡, 付出代价太大(如果你就创建一次, 不经常变动也没事, 反正只有变动时才有代价)

为了即要平衡, 又不想付出太大代价, 就有了红黑树了

当然, 红黑树消除了插入删除的代价, 所以, 对于 HashMap 的某一个 bucket, 如果元素很多, 使用红黑树是很适合了.(因为 HashMap 一般经常要删除和修改)

到了这里, 红黑树还是二叉树, 层还是比较深的, 和搜索的过程是和层的深度是有关的, 每一次要到某一层的节点加载到内存来比较.

如果所有数据都在内存没问题, 但数据要是在磁盘呢? 每加载一次就是从磁盘到内存的一次 IO, 你也知道, 磁盘读写是很慢的. 所以能不能尽量减少这种 IO 呢?

B 树就可以了, B 树不是二叉树, B 树是一种多叉搜索树, 每一个节点都有多个元素.

这样, 对于全部节点固定情况下, B 树肯定比红黑树要浅了, 这样, 潜在的最大 IO 次数一定少了啊.

所以 B 树就应用在数据库的场景下.

同理, 如果你的搜索涉及到多种速度不一的存储介质, 也是可以考虑 B 树的.


# B树

# B+树

所有的数据都存储在叶子节点上

# 红黑树

## 基本知识

在自平衡二叉搜索树的基础上, 对每个节点增加颜色位, 并满足以下条件:

1. 每个节点非红即黑;
2. 根节点是黑的;
3. 每个叶节点(不是指左右节点都为null的节点, 而是这两个null为叶子节点)都是黑的;
4. 如果一个节点是红的, 那么它的两子节点都是黑的, 父节点也是黑的(从每个叶子到根的所有路径上不能有两个连续的红色节点);
5. 对于任一节点, 到叶节点的每条路径都包含相同数目的黑色节点(即相同的黑色高度)

节点数为n, 树高则为`log n`, 最高可为 `2log(n+1)`, 深度大, 多用于内存排序

特性:

* 从根到叶子的最长的路径不多于最短的路径的两倍长

## 变色

## 旋转


## 应用实例

TreeMap

## 参考
https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91


# QA

* B树和B+树是解决什么样的问题的, 怎样演化过来, 之间区别


# 参考

1. [B+/-Tree原理](https://www.cnblogs.com/shijianchuzhenzhi/p/6666537.html)
