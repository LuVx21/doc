<details>
<summary>点击展开目录</summary>
<!-- TOC -->

- [关键字](#关键字)
    - [static](#static)
    - [final](#final)
    - [abstract](#abstract)
    - [native](#native)

<!-- /TOC -->
</details>

## 关键字

### static

可以用于修饰类,变量,方法,代码块,被修饰内容全局唯一,只加载一次,不依赖实例对象,生命周期为类级别

* 类: 被修饰的类只能作为内部类,且其中只能访问静态变量和静态方法,不依赖于外部类,区别于普通内部类需在其自身构造函数中构造外部类对象
* 方法: 存在于普通类和静态内部类中,被动执行(被调用执行).不存在于普通内部类中
* 变量: 可以存在于普通类和静态内部类
* 代码块:在加载类的时候主动执行,只在第一次创建类对象时调用,可以使用定义在其前面的静态变量,对于其后面的静态变量,只能赋值而不能访问.

> 非静态代码块:在创建对象时执行,每创建一个对象都会执行一次.执行顺序参看`jvm类加载`内容
> 静态代码块的共同点: 1. 构造方法前执行;2. 可以定义多个

### final

可用于声明类, 变量, 方法等, 使其不可被继承, 不可被修改, 不可被重写

对于修饰全局变量, 如果同时被`static`修饰, 须在声明时为其显式赋值或者使用静态代码块对其赋值

只有final修饰的变量, 可以声明时赋值, 也可以在类初始化时赋值, 如在构造函数中或普通代码块中

### abstract

用于修饰方法,使得其只有声明而没有实现, 具体在继承了该类的子类中实现.

不能同时使用的修饰符:

* final:不可重写
* private:不可继承
* static:不可重写

以上修饰符的使用都会导致子类无法重写父类的abstract方法.

### native

本地方法, 这种方法和抽象方法极其类似, 它也只有方法声明, 没有方法实现,
与抽象方法不同的是, 它把具体实现移交给了本地系统的函数库, 而没有通过虚拟机, 可以说是Java与其它语言通讯的一种机制.
使用过程:

1. 编写java代码,声明native方法
2. javac 编译代码生成class文件
3. `javah -jni class文件名`,生成`.h`文件
4. 依据`.h`文件编写c代码
5. 编译c代码为动态链接库文件

> Java语言本身是不能直接操作或访问系统底层的数据,但可以通过JNI(Java Native Interface)调用其他语言间接实现,如C等
> 通常是为了提高性能或隐藏敏感代码而使用


### sealed permits

许可类的声明需要满足下面的三个条件:

* 在编译期, 封闭类和封闭接口必须可以访问它的许可类;
* 许可类必须是封闭类或者封闭接口的`直接扩展类`或者`直接实现类`;
* 许可类必须声明是否继续保持封闭.
    * 许可类可以声明为终极类(final), 从而关闭扩展性;
    * 许可类可以声明为封闭类(sealed), 从而延续受限制的扩展性;
    * 许可类可以声明为解封类(non-sealed), 从而支持不受限制的扩展性.

> 许可类必须是封闭类的直接扩展, 因此许可类不具备传递性

### record

**进程和线程的区别**

进程(Process):

系统进行资源调度和分配的的基本单位, 实现了操作系统的并发

是Windows系统中的一个基本概念, 它包含着一个运行程序所需要的资源. 一个正在运行的应用程序在操作系统中被视为一个进程, 进程可以包括一个或多个线程.

线程是操作系统分配处理器时间的基本单元, 在进程中可以有多个线程同时执行代码.
进程之间是相对独立的, 一个进程无法访问另一个进程的数据(除非利用分布式计算方式), 一个进程运行的失败也不会影响其他进程的运行, Windows系统就是利用进程把工作划分为多个独立的区域的.
进程可以理解为一个程序的基本边界.
是应用程序的一个运行例程, 是应用程序的一次动态执行过程.

线程(Thread):

线程是进程的子任务, 是CPU调度和分派的基本单位, 用于保证程序的实时性, 实现进程内部的并发; 线程是操作系统可识别的最小执行和调度单位

是进程中的基本执行单元, 是操作系统分配CPU时间的基本单位, 一个进程可以包含若干个线程, 在进程入口执行的第一个线程被视为这个进程的主线程.
线程主要是由CPU寄存器、调用栈和线程本地存储器(Thread Local Storage, TLS)组成的.
CPU寄存器主要记录当前所执行线程的状态, 调用栈主要用于维护线程所调用到的内存与数据, TLS主要用于存放线程的状态信息.

在操作系统设计上, 从进程演化出线程, 最主要的目的就是更好的支持SMP以及减小(进程/线程)上下文切换开销.
进程拥有一个独立的虚拟内存地址空间

区别:
* 一个线程只能属于一个进程, 而一个进程可以有多个线程
* 进程在执行过程中拥有独立的内存单元, 而多个线程共享进程的内存
* 进程是资源分配的最小单位, 线程是CPU调度的最小单位
* 进程切换的开销也远大于线程切换的开销
* 进程适应于多核、多机分布; 线程适用于多核

[进程和线程的概念、区别及进程线程间通信](https://cloud.tencent.com/developer/article/1688297)

**Java中有几种类型的流?JDK为每种类型的流提供了一些抽象类以供继承, 请说出他们分别是哪些类?**

* 字节流:`InputStream`,`OutputStream`,可以处理任何类型的对象
* 字符流:`Reader`,`Writer`,只能用于处理字符

> 不能直接处理Unicode字符, 而字符流就可以

**序列化的方式**

* 实现`Serializable`接口
* 实现`Externalizable`接口,该接口继承自Serializable,并增加writeExternal和readExternal方法
* json实现
* protostuff实现
