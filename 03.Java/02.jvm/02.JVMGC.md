<details>
<summary>点击展开目录</summary>
<!-- TOC -->

- [GC](#gc)
    - [对象是否可回收](#对象是否可回收)
- [垃圾回收算法](#垃圾回收算法)
- [垃圾收集器](#垃圾收集器)
    - [CMS](#cms)
    - [G1收集器](#g1收集器)
    - [ZGC](#zgc)
- [内存分配策略](#内存分配策略)
- [GC收集器参数](#gc收集器参数)
- [GC调优](#gc调优)
- [Q&A](#qa)
- [阅读](#阅读)

<!-- /TOC -->

</details>

## GC

GC的工作内容就是回收内存, 包括哪些内存需要回收, 什么时候回收, 怎么回收等3件工作.

堆内存也被称为GC堆, 这种叫法是因为GC的主要进行场所就是堆内存, 方法区是堆内存的一部分, 同样也存在可以GC的对象,

但Java虚拟机规范不要求虚拟机在方法区实现GC, 而且在方法区进行GC的"性价比"一般都比较低, 这和方法区被称为永久代有着相同的原因.

### 对象是否可回收

在GC进行前首先要确定的就是对象是否还`活着`(是否还在直接或间接的被使用中)

判断对象的使用常有以下2种策略:

**引用计数算法**

存储对特定对象的所有引用数,也就是说,当应用程序创建引用以及引用超出范围时,JVM必须适当增减引用数.当某对象的引用数为0时,便可以进行垃圾回收.

优点: 实现简单, 效率高

缺点: 很难解决对象之间相互引用问题

**可达性分析算法**

通过一系列的称为`GC Roots`的对象作为起始点,从这些节点开始向下搜索,搜索所走的路径称为引用链

当一个对象到`GC Roots`没有任何引用链相连时,则证明此对象是不可用的.

其中可作为`GC Roots`的对象包括:

- 方法区中的类静态属性, 常量引用的对象
- JVM栈(栈中的局部变量表)中引用的对象, 如参数, 局部变量, 临时变量
- 本地方法栈中Native方法引用的对象

**垃圾回收器是怎样寻找 GC Roots 的**

为了保证结果的准确性, GC Roots枚举时是要在STW的情况下进行的

由于 JAVA 应用越来越大, 所以也不能逐个检查每个对象是否为 GC Root, 那将消耗大量的时间.

一个很自然的想法是, 能不能用空间换时间, 在某个时间把栈上代表引用的位置全部记录下来, 这样到真正 GC 的时候就可以直接读取, 而不用再一点一点的扫描了.

事实上, 大部分主流的虚拟机也正是这么做的, 比如 HotSpot , 它使用一种叫做 **OopMap** 的数据结构来记录这类信息

**OopMap**

gc 发生时:

1. 程序首先运行到最近的一个安全点停下来, 然后更新自己的 OopMap , 记下栈上哪些位置代表着引用.
2. 枚举根节点时, 递归遍历每个栈帧的 OopMap , 通过栈中记录的被引用对象的内存地址, 即可找到这些对象(GC Roots).

使用 OopMap 可以`避免全栈扫描`, 加快枚举根节点的速度.
但这并不是它的全部用意. 它的另外一个更根本的作用是, 可以帮助 HotSpot 实现准确式 GC (即使用准确式内存管理, 虚拟机可以知道内存中某个位置的数据具体是什么类型)

## 垃圾回收算法

**标记-清除算法**

Mark-Sweep, 最基础的算法,后续的算法都是基于这种思想改进而来

标记和清除过程的效率都不高, 会产生大量不连续的内存碎片, 可能导致在分配大对象时因无法找到符合的连续空间而再次触发GC

由于其缺点, 因此更适用于老年代的回收

**标记-复制算法**

为解决标记清除算法效率和会产生内存碎片问题而生, 适用于对象存活率低的新生代的回收

将内存分为一块较大的`Eden`空间和两块较小的`Survivor`空间, 每次使用Eden和其中一块Survivor,
回收时, 将Eden和Survivor中存活的对象一次性地拷贝到另一块Survivor空间, 最后清理掉Eden和Survivor空间

当对象的存活率较高时, 会进行较多的复制操作, 导致性能下降, 因此更适用于具有朝生夕死特点的新生代

**标记-整理算法**

在标记-清除算法的标记的基础上, 将不被回收的对象向同一端移动,然后清理到边界外的内存,解决了内存碎片问题

---

算法只有以上三种, 针对实际情况也会优化回收策略

**分代回收策略:**

不是一种具体的GC算法, 是一种不同代采取不同回收算法的策略.

新生代的对象生命周期短, 只有少量存活, 那就选用复制算法, 只需要付出少量存活对象的复制成本就可以完成收集.

而老年代中因为对象存活率高, 没有额外的空间进行分配担保, 就必须使用`标记-清除`或者`标记-整理`算法来进行回收.

---

**回收方法区(永久代):**

此区域的回收主要有两项内容:`废弃常量`和`无用的类`

> 为何标记整理会发生`stop the world`?
> 可达性分析进行时, 需要使对象保持一个静止的状态, 不然会出现分析过程中对象引用也在变化的情况, 导致分析结果不准确

## 垃圾收集器

垃圾收集器通常是作为一个单独的低级别的线程运行, 在不可预知的情况下对堆内存中已经死亡的或者长时间没有使用的对象进行清除和回收,

开发者不能实时的调用垃圾收集器对某个对象或所有对象进行垃圾回收.

常见垃圾收集器有:

* 串行垃圾收集器(Serial Garbage Collector): Client模式下的默认新生代收集器
* ParNew 收集器: 串行收集器的多线程版本, Server模式下首选的新生代收集器
* 并行垃圾收集器(Parallel Garbage Collector): 复制算法
* Serial Old 收集器:
* Parallel Old 收集器:
* 并发标记扫描垃圾收集器(Concurrent Mask Sweep Garbage Collector):
* G1垃圾收集器(G1 Garbage Collector): 基于`标记-整理`算法,可以精确控制停顿.基本不牺牲吞吐量的前提下完成低停顿的内存回收

| 收集器                | 算法                                     | 新生代/老年代  | STW | 内存碎片 |
| :-------------------- | :--------------------------------------- | :------------- | :-- | :------- |
| Serial                | 标记-复制                                | 新生代         | 会  | 无       |
| ParNew                | 标记-复制                                | 新生代         | 会  | 无       |
| Parallel Scavenge     | 标记-复制                                | 新生代         | 会  | 无       |
| Serial Old            | 标记-整理                                | 老年代         | 会  | 无       |
| Parallel Old          | 标记-整理                                | 老年代         | 会  | 无       |
| Concurrent Mark Sweep | 标记-清除                                | 老年代         | 会  | 会       |
| G1                    | 局部复制(两个 Region 之间), 整体标记整理 | 新生代和老年代 | 会  | 无       |

![](https://gitee.com/LuVx/img/raw/master/jvm/jvm_gc.jpg)

### CMS

基于标记-清除算法, 也被称为并发的停顿收集器, 力求降低回收停顿时间的收集器, 具体过程有`初始标记 -> 并发标记 -> 重新标记 -> 并发清除 -> 并发重置`四个过程

既然目标是降低停顿时间, 那么关键点就是在标记的过程中或部分过程中, 不能阻止对象引用的变化, 因此采用了多次标记的处理方式

实际上, 并发标记和并发清除阶段, 收集器线程都`可以和用户线程一起工作`

并发收集, 低停顿; 但也有对CPU资源非常敏感(并发特点导致), 无法处理浮动垃圾(标记结束后产生新垃圾导致),以及算法本身所具有的会产生内存碎片的缺点

### G1收集器

Garbage-First(G1,垃圾优先)收集器是服务类型的收集器, 目标是多处理器机器, 大内存机器.

应用标记-整理算法,相比于CMS能非常精确地控制停顿,高度符合垃圾收集暂停时间的目标,同时实现高吞吐量.

可以实现在基本不牺牲吞吐量的情况下完成低停顿的回收

内存划分方式:

它是将堆内存被划分为多个大小相等的 heap 区,每个heap区都是逻辑上连续的一段内存(virtual memory).

并跟踪这些区域里面的垃圾堆积程度,在后台维护一个优先列表,每次根据允许的收集时间,

优先回收垃圾最多的区域(这也是Garbage First名称的由来).

总而言之,`区域划分`和`有优先级的区域回收`, 保证了G1收集器在有限的时间内可以获得最高的收集效率.

初始标记, 并发标记, 最终标记, 筛选回收

G1只有并发标记才不会STW, 其他都会停下来

### ZGC

JDK 11中推出的一款低延迟垃圾回收器, 号称停顿不会超过10ms,

能够实现`大内存`,`低延迟`的内存管理和回收

基于标记-整理算法

与标记对象的传统算法相比, ZGC在指针上做标记, 在访问指针时加入`Load Barrier`(读屏障), 比如当对象正被GC移动, 指针上的颜色就会不对, 这个屏障就会先把指针更新为有效地址再返回,
也就是, 永远只有单个对象读取时有概率被减速, 而不存在为了保持应用与GC一致而粗暴整体的`Stop The World`.

## 内存分配策略

1. 创建新对象时, eden没有足够的空间, 会触发Minor GC
2. 过程中针对eden区及from survivor区域的存活对象进行处理
   1. 对象年龄到达阈值, 直接进入老年代
   2. 对象太大无法复制到to survivor, 直接进入老年代
   3. to survivor空间不足, 对象进入老年代
   4. 无以上场景, to survivor足够存下存活对象, 则复制进该区域
3. 回收后eden仍然空间不足, 在老年代创建对象

**对象年龄判定**

JVM给每个对象都定义一个age计数器,若对象在Eden出生并经过第一次Minor GC后仍存在并被Survivor容纳,对象age为1,之后在Survivor中每经过一次Minor GC,age加1.当age达到一定数值(默认15)就会成为老年代,默认值可以通过`-XX:MaxTenuringThreshold`修改.

实际上,JVM并不是总要求对象的年龄必需达到`MaxTenuringThreshold`才能晋升老年代,如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半,年龄大于或等于该年龄的对象就可以直接进入老年代.

## GC收集器参数

| 参数                                   | 说明                                                       |
| -------------------------------------- | ---------------------------------------------------------- |
| -XX:+UseSerialGC                       | 在新生代和老年代使用串行收集器                             |
| -XX:+UseParallelGC                     | 新生代使用并行回收收集器                                   |
| -XX:+UseParallelOldGC                  | 老年代使用并行回收收集器                                   |
| -XX:+UseParNewGC                       | 在新生代使用并行收集器                                     |
| -XX:+UseConcMarkSweepGC                | 新生代使用并行收集器,老年代使用CMS+串行收集器              |
| -XX:+UseCMSCompactAtFullCollection     | 设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片的整理  |
| -XX:UseCtpancyOnly                     | 表示只在到达阀值的时候,才进行CMS回收                       |
| -XX:SurvivorRatio                      | 设置eden区大小和survivior区大小的比例                      |
| -XX:NewRatio                           | 新生代和老年代的比                                         |
| -XX:ParallelGCThreads                  | 设置用于垃圾回收的线程数                                   |
| -XX:ParallelCMSThreads                 | 设定CMS的线程数量                                          |
| -XX:CMSInitiatingOccupancyFraction     | 设置CMS收集器在老年代空间被使用多少后触发                  |
| -XX:CMSFullGCsBeforeCompaction         | 设定进行多少次CMS垃圾回收后,进行一次内存压缩               |
| -XX:+CMSClassUnloadingEnabled          | 允许对类元数据进行回收                                     |
| -XX:CMSInitiatingPermOccupancyFraction | 当永久区占用率达到这一百分比时,启动CMS回收                 |
| -XX:+PrintGCDetails                    | 开启后,GC时打印内存回收日志,并在线程退出时输出内存分配情况 |

## GC调优

调优目标?

内存占用(footprint), 延时(latency)和吞吐量(throughput)

确认JVM和GC的状态, 定位具体的问题

排查具体问题表现在哪里, 是`Minor GC`过长, 还是`Mixed GC`等出现异常停顿情况

**如何进行jvm优化? 有几种 gc fail? 哪些参数调优? 如何排查gc问题?**

| GC cause                | 产生原因                                                                                                                                         | 触发GC类型            |
| :---------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------- | :-------------------- |
| Allocation Failure      | 新生代没有足够的空间分配对象                                                                                                                     | Young GC              |
| GCLocker Initiated GC   | 如果线程执行在JNI临界区时, 刚好需要进行GC, 此时GC locker将会阻止GC的发生, 同时阻止其他线程进入JNI临界区, 直到最后一个线程退出临界区时触发一次GC. | GCLocker Initiated GC |
| Promotion Failure       | 老年代没有足够的连续空间分配给晋升的对象(即使总可用内存足够大)                                                                                   | Full GC               |
| Concurrent Mode Failure | CMS GC运行期间, 老年代预留的空间不足以分配给新的对象                                                                                             | Full GC               |

## Q&A

**Java中的大对象如何进行存储;**

大对象直接进入老年代

**Minor GC与Full GC分别在什么时候发生?什么时候触发Full GC**

| 类型     | GC对象                                | 触发时机                     |
| :------- | :------------------------------------ | :--------------------------- |
| Minor GC | 回收新生代, 包括Eden 和 Survivor 区域 | 无法为一个新的对象分配空间时 |
| Major GC | 永久代                                |                              |
| Full GC  | 整个堆空间                            |                              |

针对HotSpot VM的实现, 它里面的GC其实准确分类只有两大种:

* Partial GC: 并不收集整个GC堆的模式
  * Young GC: 只收集young gen的GC
  * Old GC: 只收集old gen的GC. 只有CMS的concurrent collection是这个模式
  * Mixed GC: 收集整个young gen以及部分old gen的GC. 只有G1有这个模式
* Full GC: 收集整个堆, 包括young gen, old gen, perm gen(如果存在的话)等所有部分的模式.

Major GC通常是跟Full GC是等价的, 收集整个GC堆. 但因为HotSpot VM发展了这么多年, 外界对各种名词的解读已经完全混乱了, 当有人说`major GC`的时候一定要问清楚他想要指的是上面的Full GC还是Old GC.

> 作者: RednaxelaFX<br/>
> 链接:<br/>
> https://www.zhihu.com/question/41922036/answer/93079526 <br/>
> 来源: 知乎<br/>
> 著作权归作者所有. 商业转载请联系作者获得授权, 非商业转载请注明出处.<br/>

**Minor GC发生的频繁的原因?GC的时间长的原因是什么**

频繁:

* 创建了大量新对象, 且这些对象都短命
* 新生代空间配置过小

时间长:

1. 新生代空间设置过大
2. 对象引用链较长, 进行可达性分析时间较长
3. 新生代to survivor区设置的比较小, GC过程出现将对象移动到老年代的现象, 造成移动开销
4. 内存分配担保失败, 由Minor gc转化为Full gc(新生代所有对象总空间大于老年代最大连续空间)
5. 采用的垃圾收集器效率较低, 比如新生代使用serial收集器

**Full GC次数太多了, 如何优化**

创建大对象, 甚至还短命, 容易造成Full GC

**CMS收集器与G1收集器的特点**

CMS 在并发标记和并发清除阶段都是可以和用户线程同步进行的, G1 则只有并发标记阶段这样

G1 可以建立可预测的停顿时间模型

**为什么新生代内存需要有两个Survivor区?**

复制算法

**CMS回收步骤, CMS为什么会停顿, 停顿时间;**

**每个算法的优缺点啊, 怎么简单的解决啊**

增加堆的大小, 增加后台线程, 提前开始并发周期等

**有没有了解G1收集器这些, G1的流程, 相比CMS有哪些优势.**

并行和并发, 分代收集, 空间整合, 可预测的停顿

**如何手动触发Full GC?**

没有开启`-XX:+DisableExplicitGC`的前提下调用`System.gc()`就会发生`Full GC`

或者通过jmap命令触发:`jmap -histo:live {pid}`

## 阅读
