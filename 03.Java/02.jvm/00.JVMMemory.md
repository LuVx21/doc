---
title: JVM2:内存结构
date: 2017-11-06
tags:
- Java
- JVM
---
<details>
<summary>点击展开目录</summary>
<!-- TOC -->

- [内存结构](#内存结构)
    - [程序计数器(Program Counter Register)](#程序计数器program-counter-register)
    - [JVM栈(JVM Stacks)](#jvm栈jvm-stacks)
    - [本地方法栈(Native Method Stacks)](#本地方法栈native-method-stacks)
    - [堆内存(Heap)](#堆内存heap)
    - [方法区(Method Area)](#方法区method-area)
    - [运行时常量池](#运行时常量池)
    - [直接内存](#直接内存)
- [堆栈比较](#堆栈比较)
- [内存空间分配策略](#内存空间分配策略)
- [内存溢出异常](#内存溢出异常)
    - [内存泄漏](#内存泄漏)
    - [常见错误](#常见错误)
    - [一些代码](#一些代码)
- [QA](#qa)
- [参考](#参考)

<!-- /TOC -->

</details>

# 内存结构

![](https://gitee.com/LuVx/img/raw/master/jvmme.png)

更详细的图:

![](https://gitee.com/LuVx/img/raw/master/jvm/jvm_mm.jpg)

* 堆内存
  * 新生代(8:1:1)
    * Eden空间
    * From Survivor
    * To Survivor
  * 老年代
* 方法区
* 栈
  * java虚拟机栈
  * 本地方法栈

| 区域         | 作用                                              | 共享性 | 存储内容                                              |
| ------------ | ------------------------------------------------- | ------ | ----------------------------------------------------- |
| 程序计数器   | 比较小的内存区域,指示当前线程所执行的字节码的位置 | ×     | 正在执行的VM字节码指令地址(Java方法,native方法时为空) |
| JVM栈        | 记录方法调用                                      | ×     | 局部变量表,对象的引用指针                             |
| 本地方法栈   | 执行Native方法时使用                              | ×     | -                                                     |
| 堆内存       | 存放对象实例,可以细分为新生代和老年代             | √     | new出来的对象(属性,方法的地址(指向方法区))            |
| 方法区       | 内有运行时常量池,也有人称之为永久代               | √     | 类信息(属性,方法),常量,static变量                     |
| 运行时常量池 | 方法区的一部分                                    | √     | 运行时常量池(各种字面量和符号引用)                    |

![内存结构](https://gitee.com/LuVx/img/raw/master/jvm01.png)

## 程序计数器(Program Counter Register)

一块较小的内存空间, 属于线程私有.

字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令, 分支, 循环, 跳转, 异常处理, 线程恢复等基础功能都需要依赖这个计数器来完成.
如果线程正在执行一个java方法,这个计数器记录的是正在执行的虚拟机字节码指令的地址;

如果是Native方法,则计数器为空;多线程时, 存在多个程序计数器.

此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域.

## JVM栈(JVM Stacks)

![](https://gitee.com/LuVx/img/raw/master/jvm/jvm_stack.png)

线程私有, 生命周期与线程相同

虚拟机栈描述的是Java方法执行的内存模型:每个方法被执行的时候都会同时创建一个栈帧(Stack Frame)用于存储局部变量表, 操作栈, 动态链接, 方法出口等信息.

每一个方法被调用直至执行完成的过程, 就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程.

局部变量表所需的内存空间在编译期间完成分配,当进入一个方法时该方法对应的需要在栈帧中分配多大的局部变量空间是完全确定的.

对这个区域规定了两种异常状况:
如果线程请求的栈深度大于虚拟机所允许的深度, 将抛出 `StackOverflowError`异常;
如果虚拟机栈可以动态扩展(当前大部分的Java虚拟机都可动态扩展, 只不过Java虚拟机规范中也允许固定长度的虚拟机栈), 当扩展时无法申请到足够的内存时会抛出 `OutOfMemoryError`异常.

> 栈帧: 一个栈帧随着一个方法的调用开始而创建,这个方法调用完成而销毁.栈帧内存放着方法中的局部变量,操作数栈等数据

方法体内, 基本类型不同的变量存储位置也有所不同:

基本数据类型的局部变量以及数据都是直接存储在内存中的栈的局部变量表中, 而且数据在当前线程下是共享的, 如定义了两个基本类型的局部变量, 值一样, 那么这两个变量的指向是相同的

修改这样的局部变量时, 并不是直接改变数值的内容, 而是先找到有没有这样的数值, 没有才会开辟内存存储新数据, 然后确定指向

而引用类型的成员变量则是和对象一样存储在堆中, 其生命周期和对象相同

基本类型的静态变量则是存储在方法区的运行时常量池中, 其生命周期和类相同

对于引用对象, 会在 jvm 栈中开辟空间存储引用, 而具体的对象在堆中, 之后再引用指向这个对象, 因此对于对象及数组, 栈中引用不存储真实数据, 而是对象的地址

## 本地方法栈(Native Method Stacks)

虚拟机栈为虚拟机执行Java方法(也就是字节码)服务, 而本地方法栈则是为虚拟机使用到的Native方法服务

异常抛出类型和JVM栈相同

## 堆内存(Heap)

Java堆是被所有线程共享的一块内存区域, 在虚拟机启动时创建.此内存区域的唯一目的就是存放对象实例, 大多数的对象实例都在这里分配内存.

Java堆是垃圾收集器管理的主要区域, 因此很多时候也被称做"GC堆"
多采用分代收集策略,所以细分为新生代和老年代,新生代再细分可分为 `Eden`空间,`From Survivor`空间,`To Survivor`空间,在GC的复制算法中起着重要作用,HotSpot VM默认的Eden和Survivor大小比例为 `8:2`(两个Survivor)

堆内存可以是物理上不连续的内存空间, 逻辑上连续即可,

在堆中没有内存完成实例分配, 并且堆也无法再扩展时, 将会抛出 `OutOfMemoryError`异常

## 方法区(Method Area)

与Java堆一样, 是各个线程共享的内存区域, 它用于存储已被虚拟机加载的类信息, 常量, 静态变量, 即时编译器编译后的代码等数据,有时也被称为 `永久代(PermGen)`

JDK1.7 `字符串常量池`被从方法区拿到了堆中, 不在方法区了, JDK1.8 hotspot移除了永久代并用元空间取代

Java虚拟机规范对这个区域的限制非常宽松, 除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外, 还可以选择不实现垃圾收集

这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载

当方法区无法满足内存分配需求时, 将抛出 `OutOfMemoryError`异常

![](https://gitee.com/LuVx/img/raw/master/classloader0.png)

![](https://gitee.com/LuVx/img/raw/master/jvm02.png)

> 对方法区和永久区的理解以及它们之间的关系:
> 永久代是HotSpot的概念, 方法区是Java虚拟机规范中的定义, 是一种规范, 而永久代是一种实现, 一个是标准一个是实现
> 虽然方法区也常被称为永久代, 实际上两者并不等价, 仅仅是因为方便像堆一样管理这片内存, 从而将GC分代收集扩展到方法区

## 运行时常量池

是方法区的一部分,存放编译期生成的各种字面量和符号引用,当JVM运行的时候会将这些常量池的信息加载进方法区.

当方法区无法满足内存分配需求时,抛出 `OutOfMemoryError`

## 直接内存

不是虚拟机运行时数据区的一部分,也不是Java虚拟机规范中定义的内存区域,但是这部分内存也被频繁的使用.

也可能导致 `OutOfMemoryError`异常出现

NIO的Buffer提供了一个可以不经过JVM内存直接访问系统物理内存的类-`DirectBuffer`.
该类继承自 `ByteBuffer`, 但和普通的 `ByteBuffer`不同, 普通的 `ByteBuffer`仍在JVM堆上分配内存, 其最大内存受到最大堆内存的限制;
而 `DirectBuffer`直接分配在物理内存中, 并不占用堆空间, 其可申请的最大内存受操作系统限制.

直接内存的读写操作比普通Buffer快, 但它的创建, 销毁比普通Buffer慢(猜测原因是 `DirectBuffer`需向OS申请内存涉及到用户态内核态切换, 而后者则直接从堆内存划内存即可).

总结下来就是与在JVM堆分配内存(`allocate`)相比, 直接内存分配(`allocateDirect`)的访问性能更好, 但分配较慢.

因此直接内存适用于需要大内存空间且频繁访问的场合, 不适用于频繁申请释放内存的场合.

使用堆外内存的原因:

* 对垃圾回收停顿的改善. 由于堆外内存是直接受操作系统管理而不是JVM, 所以当我们使用堆外内存时, 即可保持较小的堆内内存规模. 从而在GC时减少回收停顿对于应用的影响.
* 提升程序I/O操作的性能. 通常在I/O通信过程中, 会存在堆内内存到堆外内存的数据拷贝操作, 对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据, 都建议存储到堆外内存.

以上内容取自[Java直接内存与堆内存](https://www.cnblogs.com/z-sm/p/6235157.html)

# 堆栈比较

* 栈内存用来存储局部变量和方法调用.
* 堆内存用来存储Java中的对象.无论是成员变量,局部变量,还是类变量,它们指向的对象都存储在堆内存中.
* 基本类型的变量: 变量和引用存在栈中; 基本类型的常量: 引用在栈中, 常量在常量池中.

# 内存空间分配策略

对象主要分配在新生代的Eden区,少数情况下会直接分配在老年代中.

分配策略:

1. 对象优先在eden分配
2. 大对象直接进入老年代
3. 动态对象年龄判定
4. 长期存活的对象进入老年代
5. 空间分配担保机制

# 内存溢出异常

指程序在申请内存时, 没有足够的内存空间供其使用, 这时系统会抛出OutOfMemoryError异常

产生该错误的原因主要包括:

* JVM内存过小
* 程序不严密, 产生了过多的垃圾

现象:

* 内存中加载的数据量过于庞大, 如一次从数据库取出过多数据
* 集合类中有对对象的引用, 使用完后未清空, 使得JVM不能回收
* 代码中存在死循环或循环产生过多重复的对象实体
* 启动参数内存值设定的过小

## 内存泄漏

程序在申请内存后, 无法释放已申请的内存空间

以下是防止内存泄漏的一些快速实用技巧.

* 注意集合类, 如HashMap、ArrayList等, 因为它们是发现内存泄漏的常见地方. 当它们被声明为静态时, 它们的生命时间与应用程序的生命时间是相同的.
* 注意事件监听器和回调. 如果一个侦听器被注册了, 但是当类不再被使用时, 可能会发生内存泄漏.
* 如果一个类管理自己的内存, 程序应该对内存泄漏保持警惕. 通常情况下, 指向其他对象的成员变量需要为null值.

内存泄露, 多是因为程序的逻辑不严谨, 常见原因如:

* 内存中加载的数据量过于庞大, 如一次从数据库取出过多数据
* 集合类中有对对象的引用, 使用完后未清空, 使得JVM不能回收, 特别是定义为 static 的场景
* HashMap的 key 没有实现hashCode 和 equals 方法
* 代码中存在死循环或循环产生过多重复的对象实体
* 递归调用时, 创建了过多对象, 调用深度过深, 导致内存溢出
* 非静态内部类对象依赖于外部类对象, 会延长外部类的生命周期
* `finalize()`被重写时, 就不会立即被 GC, 会放入队列进行最终确定后回收
* 不合理的使用 ThreadLocal
* 使用流时没有关闭
* 启动参数内存值设定的过小


## 常见错误

`Exception in thread "main": java.lang.OutOfMemoryError: Java heap space`

原因: 对象不能被分配到堆内存中

`Exception in thread "main": java.lang.OutOfMemoryError: PermGen space`

原因: 类或者方法不能被加载到永久代.它可能出现在一个程序加载很多类的时候, 比如引用了很多第三方的库;

`Exception in thread "main": java.lang.OutOfMemoryError: Requested array size exceeds VM limit`

原因: 创建的数组大于堆内存的空间

`Exception in thread "main": java.lang.OutOfMemoryError: request <size> bytes for <reason>. Out of swap space?`

原因: 分配本地分配失败.JNI, 本地库或者Java虚拟机都会从本地堆中分配内存空间.

`Exception in thread "main": java.lang.OutOfMemoryError: <reason> <stack trace>(Native method)`

原因: 同样是本地方法内存分配失败, 只不过是JNI或者本地方法或者Java虚拟机发现

`java.lang.OutOfMemoryError: unable to create new native thread`

原因: 创建了太多的线程,而能创建的线程数是有限制的,导致了异常的发生

## 一些代码

```Java
long maxMemory = Runtime.getRuntime().maxMemory();
long totalMemory = Runtime.getRuntime().totalMemory();
System.out.println("MAX_MEMORY = " + maxMemory + "(字节), " + (maxMemory / (double) 1024 / 1024) + "MB");
System.out.println("TOTAL_MEMORY = " + totalMemory + "(字节), " + (totalMemory / (double) 1024 / 1024) + "MB");
```

# QA

**区分内存溢出和内存泄露**

内存溢出: 程序在申请内存时, 没有足够的内存空间供其使用, 出现out of memory

内存泄露: 程序在申请内存后, 无法释放已申请的内存空间, 过多的泄露导致内存无法回收, 无法使用了, 最终就会导致内存溢出

通常使用下, 感觉不到泄露的存在

# 参考

1. 深入理解Java虚拟机
