---
title: 并发编程:锁
date:
tags:
- Java
---
<details>
<summary>点击展开目录</summary>
<!-- TOC -->

- [锁的知识](#锁的知识)
- [Lock](#lock)
- [ReadWriteLock](#readwritelock)
- [锁优化](#锁优化)
- [JVM的优化](#jvm的优化)
- [死锁预防](#死锁预防)
- [Q&A](#qa)
- [参考](#参考)

<!-- /TOC -->
</details>

## 锁的知识

悲观锁: 对于共享资源, 持锁线程总是认为会有其他线程来修改资源, 因此在持锁期间会对资源进行加锁

乐观锁: 认为不会有其他线程修改资源, 因此不会加锁, 而是在修改数据时判断资源是否已被其他线程修改


排他锁: 线程对资源加锁后, 其他线程不能再对资源加任何类型的锁, 持锁线程能读也能写资源

共享锁: 线程对资源加锁后, 其他线程能继续加共享锁, 但不能加排他锁, 共享锁的持锁线程, 只能读取而不能写资源


公平锁: 多个线程按照申请锁的顺序去获取锁, 因此存在着一个队列

非公平锁: 多个线程在申请锁时就去获取锁, 获取失败才去排队


重入锁: 持锁线程再次获取这个锁时, 能够自动获取锁

非重入锁: 与重入锁相反, 不能自动获取锁, 而是要释放现在持有的锁


`synchronized`的实现是依赖于Monitor, 而Monitor是依赖于底层的操作系统的`Mutex Lock`(互斥锁)来实现的线程同步

因此, 阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成, 这种状态转换需要耗费处理器时间.

如果同步代码块中的内容过于简单, 状态转换消耗的时间有可能比用户代码执行的时间还要长.

这种方式就是synchronized最初实现同步的方式, 这就是JDK 6之前synchronized效率低的原因.

这种依赖于操作系统`Mutex Lock`所实现的锁我们称之为`重量级锁`

为了减少获得锁和释放锁带来的性能消耗, 引入了`偏向锁`和`轻量级锁`

偏向锁: 锁偏向于第一个获取它的线程, 接下来的执行过程中, 不被其他线程获取, 那么持锁线程永远不需要同步

轻量级锁: 偏向锁被其他线程获取时, 升级为轻量级锁, 获锁失败的线程通过自旋的方式尝试获取锁而不是进入阻塞

自旋锁: 线程获取锁失败时, 而不是进入阻塞而是进入一个忙循环后再尝试获取锁, 由于此时处于忙等待的状态, 所以只适合锁占用时间较短的场景

适应性自旋锁: 自旋锁迟迟不能获取到锁, 白白占用处理器却不做事, 自旋的效果就很差, 所以可以自旋不确定的时间, 这个时间由以前在这个锁上自旋的时间及锁拥有者的状态决定

互斥锁: 线程获取锁失败时, 会被挂起, 处于`sleep-waiting`状态, 当锁被释放时, 该线程会被唤醒重新竞争锁, 由于线程的挂起和唤醒都需要线程切换性能不是很好, 所以适用于锁占用时间较长的场景

## Lock

是一个接口, 其最常见的实现类为`ReentrantLock`

```Java
void lock();
void lockInterruptibly() throws InterruptedException;
boolean tryLock();
boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
void unlock();
Condition newCondition();
```

## ReadWriteLock

是一个接口, 其最常见的实现类为`ReentrantReadWriteLock`

ReentrantLock锁是完全排他锁,同一时间只有一个线程能执行`lock.lock()`和`lock.unlock()`之间的代码, 实际的业务场景中往往是读多写少, 而读不涉及数据竞争,
因此, 为了读而加锁必定影响其他线程的读或写, 因此出现了读写锁.

仅有2个方法:
```Java
Lock readLock();
Lock writeLock();
```

## 锁优化

锁竞争及上下文切换会导致程序性能的下降,因此对锁的优化也是有必要的.

* 减少锁持有的时间:和降低锁粒度很相似,不要将耗时的操作放入同步域
* 减小锁粒度:Java7中ConcurrentHashMap的实现就利用了这种优化方式
* 读写锁替换独占锁:ReentrantReadWriteLock区别于ReentrantLock的地方就体现出这种方式,只有涉及到写操作才会阻塞
* 锁分离:读写锁的基础上更进一步,LinkedBlockingQueue(基于链表的阻塞队列,读写分离)就使用了这种方式,存在takeLock和putLock两种锁
* 锁粗化:多个锁合并为同一个锁,与减小锁粒度相反,增大了同步域以避免频繁切换上下文,所以有特殊的适用场景
* 锁消除:编译器发现不可能被共享的对象,可以消除这些对象的锁操作,如某些类的方法时加了锁,但却用在不会有线程安全问题的情形下
* JVM的优化:偏向锁, 轻量级锁, 重量级锁等

## JVM的优化

synchronized的锁是互斥锁, 对性能有很大影响, 因此从Java6开始引入了偏向锁和轻量级锁, 以及锁的存储结构和锁升级机制.

synchronized锁是存在Java对象头中, 数组类型用3个字宽(Word)存储对象头, 其他类型用2个字宽(32位VM下1字宽为4字节).

![](https://gitee.com/LuVx/img/raw/master/obj_head.png)

HotSpot虚拟机对象头的`Mark Word`(32位):

| 锁状态   | 25位                            | 4位          | 是否为偏向锁(1位) | 锁标志位(2位) |
| -------- | ------------------------------- | ------------ | ----------------- | ------------- |
| 无锁状态 | 对象的hashcode                  | 对象分代年龄 | 0                 | 01            |
| 偏向锁   | 23bit线程ID+2bit Epoch          | 对象分代年龄 | 1                 | 01            |
| 轻量级锁 | 指向调用栈中锁记录的指针(30bit) | 合并到左     | 合并到左          | 00            |
| 重量级锁 | 指向重量级锁的指针(30位)        | 合并到左     | 合并到左          | 10            |
| GC标记   | 空                              | 空           | 空                | 11            |

> 其中, 锁状态共有4种, 级别从低到高依次是: 无锁状态, 偏向锁状态, 轻量级锁状态和重量级锁状态, 锁可以升级且不能逆向

偏向锁:

![](https://gitee.com/LuVx/img/raw/master/偏向锁.png)

轻量级锁:

![](https://gitee.com/LuVx/img/raw/master/轻量级锁.png)

* 自旋锁: 避免挂起线程的一种尝试.如果线程一直无法获得锁, 并且能获取的时间点也未知, 就会让当前线程做几个空循环
* 偏向锁: 偏向锁就是一旦线程第一次获得了监视对象, 之后让监视对象"偏向"这个线程, 之后的多次调用则可以避免CAS操作
* 轻量级锁: 偏向锁运行在一个线程进入同步块的情况下, 当第二个线程加入锁竞争的时候, 偏向锁就会升级为轻量级锁
* 重量级锁: JVM中又叫对象监视器(Monitor), 它至少包含一个竞争锁的队列和一个信号阻塞队列(wait队列), 前者负责做互斥, 后一个用于做线程同步.

| 锁       | 偏向锁                                                       | 轻量级锁                                 | 重量级锁                       |
| -------- | ------------------------------------------------------------ | ---------------------------------------- | ------------------------------ |
| 优点     | 加, 解锁不需要额外的消耗, 和执行非同步方法相比仅存在纳秒级差距 | 竞争的线程不会阻塞, 提高了程序的响应速度  | 线程竞争不使用自旋, 不会消耗CPU |
| 缺点     | 如果线程间存在锁竞争, 会带来额外的锁撤销的消耗                | 始终得不到锁竞争的线程, 使用自旋会消耗CPU | 线程阻塞, 响应时间慢            |
| 适用场景 | 一个线程访问同步块场景                                       | 追求响应时间, 同步块执行速度非常快        | 追求吞吐量, 同步块执行时间较长  |

## 死锁预防

* 以确定的顺序获得锁: 在设计时即考虑到不同线程间锁获取的顺序.
* 超时放弃: 使用synchronized获取锁时,只要没有获取到锁就会一直等待,但Lock接口实现了`tryLock()`,可以指定超时时间,

## Q&A

***synchronized和ReentrantLock***

synchronized和java.util.concurrent.locks.Lock的异同

还包括了中断锁等待和定时锁等待

在并发量小的时候, 用synchronized是比较好的选择, 并发量大的时候用Lock.

Lock有比synchronized更精确的线程语义和更好的性能.

synchronized是自动释放锁, Lock是主动释放锁, 并且必须在`finally`语句中释放

Lock可中断, 可以设定所等待的时间, 可尝试获取锁(`tryLock(long timeout, TimeUnit unit)`, 等待可中断), 可绑定多个Condition

有些操作不会发生冲突现象, 需要用Lock解决, 比如同时读文件

synchronized是非公平锁, ReentrantLock默认情况下也是非公平锁, 但可以通过带布尔值的构造函数要求使用公平锁.

都是可重入的.

> [参照1](http://blog.csdn.net/maoyeqiu/article/details/46661719)
> [参照2](https://blog.csdn.net/zheng548/article/details/54426947)

**lock的原理是什么?**

通过AQS(AbstractQueuedSynchronizer)来维护一个int

FIFO等待队列管理获取锁的所有线程.

在"公平锁"的机制下, 线程依次排队获取锁; 而"非公平锁"在锁是可获取状态时, 不管自己是不是在队列的开头都会获取锁.

## 参考

1. [AbstractQueuedSynchronizer加锁和解锁分析(二)](http://suo.iteye.com/blog/1329460)
2. [不可不说的Java"锁"事](https://tech.meituan.com/2018/11/15/java-lock.html)
